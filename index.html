<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { background: #050505; color: #0f6; font-family: 'Courier New', monospace; text-align: center; margin: 0; display: flex; flex-direction: column; height: 100vh; justify-content: center; }
        #panel { border: 2px solid #0f6; display: inline-block; padding: 30px; border-radius: 15px; background: #000; box-shadow: 0 0 20px rgba(0,255,102,0.1); }
        #output { font-size: 60px; margin: 20px; min-height: 70px; color: #fff; word-break: break-all; }
        #buffer { font-size: 30px; color: #444; height: 40px; letter-spacing: 5px; }
        #state { display: inline-block; width: 100px; padding: 10px; border: 1px solid #0f6; font-weight: bold; margin-bottom: 15px; }
        .tx-active { background: #f00 !important; color: #fff !important; border-color: #f00 !important; box-shadow: 0 0 15px #f00; }
    </style>
</head>
<body onclick="init()">
    <div id="panel">
        <div id="state">RX</div>
        <div id="info">MODE: STRAIGHT | 20 WPM</div>
        <div id="buffer"></div>
        <div id="output">CLICK TO START</div>
    </div>

<script>
    let ctx, osc, gain, morse = {".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z", "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "..--..":"?", "-.-.--":"!"};
    let mode = 'S', wpm = 20, unit = 1200/wpm, seq = "", txt = "", lastUp = 0, downT = 0, paddle = null, gen = false;
    let txDelayTimer = null; 

    function init() { if(!ctx) { ctx = new AudioContext(); gain = ctx.createGain(); gain.connect(ctx.destination); gain.gain.value = 0; document.getElementById('output').innerText=""; } }

    // TX 상태 제어 (깜빡임 방지용 BKIN 딜레이)
    function setTX(on) {
        const el = document.getElementById('state');
        if(on) {
            if(txDelayTimer) clearTimeout(txDelayTimer);
            el.innerText = 'TX'; el.classList.add('tx-active');
            if(!osc) {
                osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value=620; osc.connect(gain); osc.start();
                gain.gain.setTargetAtTime(0.15, ctx.currentTime, 0.003);
            }
        } else {
            gain.gain.setTargetAtTime(0, ctx.currentTime, 0.003);
            if(osc) { osc.stop(ctx.currentTime + 0.05); osc = null; }
            // 800ms 딜레이 후 RX로 복귀 (패들 연타 시 깜빡임 방지)
            if(txDelayTimer) clearTimeout(txDelayTimer);
            txDelayTimer = setTimeout(() => {
                el.innerText = 'RX'; el.classList.remove('tx-active');
            }, 800);
        }
    }

    // 부호 추가 및 실시간 해독
    function add(s) {
        seq += s;
        document.getElementById('buffer').innerText = seq;
        lastUp = Date.now();
        // 글자 해독 타이머는 별도로 작동 (3 unit 이상 쉬면 해독)
    }
    
    function decode() {
        if(!seq) return;
        let char = morse[seq] || "";
        if(char) {
            txt += char;
            document.getElementById('output').innerText = txt;
        }
        seq = ""; document.getElementById('buffer').innerText = "";
    }

    function pLoop() {
        if(!paddle || gen) return; gen = true;
        let s = (paddle === '[') ? '.' : '-';
        let d = (s === '.') ? unit : unit * 3;
        add(s); setTX(true);
        setTimeout(() => { 
            gain.gain.setTargetAtTime(0, ctx.currentTime, 0.003); // 소리만 끔
            setTimeout(() => { 
                gen = false; 
                if(paddle) pLoop(); 
                else setTX(false); 
            }, unit); 
        }, d);
    }

    window.onkeydown = (e) => {
        if(e.repeat) return; init();
        if(e.key.toLowerCase()==='m') { mode=(mode==='S'?'P':'S'); document.getElementById('info').innerText="MODE: "+(mode==='S'?'STRAIGHT':'PADDLE')+" | "+wpm+" WPM"; return; }
        if(e.key==='ArrowUp') { wpm++; unit=1200/wpm; document.getElementById('info').innerText="MODE: "+(mode==='S'?'STRAIGHT':'PADDLE')+" | "+wpm+" WPM"; return; }
        if(e.key==='ArrowDown') { wpm--; unit=1200/wpm; document.getElementById('info').innerText="MODE: "+(mode==='S'?'STRAIGHT':'PADDLE')+" | "+wpm+" WPM"; return; }
        
        if(mode==='S' && e.code==='Space') { downT = Date.now(); setTX(true); }
        if(mode==='P' && (e.key==='[' || e.key===']')) { paddle = e.key; pLoop(); }
    };

    window.onkeyup = (e) => {
        if(mode==='S' && e.code==='Space') {
            let dur = Date.now() - downT;
            add(dur < unit * 2.2 ? '.' : '-');
            setTX(false);
        }
        if(mode==='P' && (e.key==='[' || e.key===']')) paddle = null;
    };

    // 해독 및 단어 공백 감시 루프
    setInterval(() => {
        let now = Date.now();
        let gap = now - lastUp;

        // 1. 글자 해독 (부호 간격 3 unit 기준)
        if(seq && gap > unit * 3 && !paddle && !gen && !osc) {
            decode();
        }

        // 2. 단어 공백 (단어 간격 7 unit 기준)
        if(txt && !seq && gap > unit * 7 && !txt.endsWith(" ")) {
            txt += " ";
            document.getElementById('output').innerText = txt;
        }
    }, 50);
</script>
</body>
</html>
