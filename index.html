<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Morse Master - Ultimate</title>
    <style>
        :root { --neon: #00ff66; --tx-red: #ff3333; }
        body { background: #050505; color: var(--neon); font-family: 'Courier New', monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        #status-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 30, 15, 0.9); padding: 25px;
            border: 2px solid var(--neon); border-radius: 12px; z-index: 100;
        }
        .label { font-size: 11px; color: #88ffbb; margin-bottom: 2px; }
        .val { font-size: 20px; font-weight: bold; margin-bottom: 12px; color: #fff; }
        .indicator {
            display: inline-block; width: 90px; text-align: center;
            padding: 8px 0; font-weight: bold; border-radius: 4px;
            transition: 0.15s; border: 1px solid transparent;
        }
        .rx { background: #002200; color: var(--neon); border-color: var(--neon); }
        .tx { background: var(--tx-red); color: white; box-shadow: 0 0 20px var(--tx-red); }

        #main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #buffer { font-size: 36px; color: #444; height: 50px; letter-spacing: 5px; }
        #output { font-size: clamp(30px, 5vw, 60px); width: 85%; text-align: center; word-wrap: break-word; min-height: 80px; color: #eee; }

        #footer { padding: 20px; background: #0a0a0a; color: #444; text-align: center; font-size: 13px; border-top: 1px solid #111; }
        kbd { border: 1px solid #333; padding: 2px 6px; border-radius: 4px; background: #111; color: #777; }
    </style>
</head>
<body onclick="initAudio()">

<div id="status-panel">
    <div class="label">MODE</div>
    <div id="mode-text" class="val">STRAIGHT</div>
    <div class="label">SPEED</div>
    <div id="wpm-text" class="val">20 WPM</div>
    <div id="state-indicator" class="indicator rx">RX</div>
</div>

<div id="main">
    <div id="buffer"></div>
    <div id="output">CLICK SCREEN TO INIT</div>
</div>

<div id="footer">
    [<kbd>M</kbd>] 모드 전환 | [<kbd>↑/↓</kbd>] WPM 조절 | [<kbd>Space</kbd>] 스트레이트 | [<kbd>[</kbd> <kbd>]</kbd> 패들
</div>

<script>
    let audioCtx = null, oscillator = null, gainNode = null;
    const morseDict = { ".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z", "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "..--..":"?", "-.-.--":"!" };

    let mode = 'straight';
    let wpm = 20;
    let unit = 1200 / wpm;
    let currentSeq = "", decodedText = "", lastInputTime = Date.now();
    let isGenerating = false, activePaddle = null, isStraightDown = false;
    let bkinTimer = null; // BKIN 유지 타이머

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        gainNode.connect(audioCtx.destination);
        document.getElementById('output').innerText = "";
    }

    // 소리 제어 (UI 표시 유지 로직 포함)
    function soundControl(on) {
        if (!audioCtx) return;
        if (on) {
            if (oscillator) oscillator.stop();
            oscillator = audioCtx.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(620, audioCtx.currentTime);
            oscillator.connect(gainNode);
            oscillator.start();
            gainNode.gain.setTargetAtTime(0.15, audioCtx.currentTime, 0.003);
            
            // TX 상태로 전환 및 기존 타이머 제거
            setUIState(true);
            if (bkinTimer) clearTimeout(bkinTimer);
        } else {
            gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.003);
            
            // 핵심: 소리가 꺼져도 바로 RX로 가지 않고 800ms 대기 (BKIN)
            if (bkinTimer) clearTimeout(bkinTimer);
            bkinTimer = setTimeout(() => {
                setUIState(false);
                decode(); // BKIN이 끝날 때 글자 해독
            }, 800);
        }
    }

    function setUIState(isTX) {
        const ind = document.getElementById('state-indicator');
        ind.innerText = isTX ? "TX" : "RX";
        ind.className = "indicator " + (isTX ? "tx" : "rx");
    }

    function addSym(s) {
        currentSeq += s;
        document.getElementById('buffer').innerText = currentSeq;
        lastInputTime = Date.now();
    }

    function decode() {
        if (currentSeq === "") return;
        decodedText += (morseDict[currentSeq] || "?");
        document.getElementById('output').innerText = decodedText;
        currentSeq = "";
        document.getElementById('buffer').innerText = "";
    }

    // 아이앰빅 패들 프로세스
    function paddleProcess() {
        if (isGenerating || !activePaddle) return;
        isGenerating = true;

        const sym = (activePaddle === '[') ? '.' : '-';
        const duration = (sym === '.') ? unit : unit * 3;

        addSym(sym);
        soundControl(true);

        setTimeout(() => {
            // 소리만 끄고 TX 유지는 soundControl 내부의 setTimeout이 담당
            gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.003); 
            
            setTimeout(() => {
                isGenerating = false;
                if (activePaddle) {
                    paddleProcess();
                } else {
                    // 패들을 완전히 뗐을 때만 해독 대기 타이머(BKIN) 작동 시작
                    soundControl(false);
                }
            }, unit);
        }, duration);
    }

    window.addEventListener('keydown', (e) => {
        if (e.repeat) return;
        initAudio();

        if (e.key.toLowerCase() === 'm') {
            mode = (mode === 'straight' ? 'paddle' : 'straight');
            document.getElementById('mode-text').innerText = mode.toUpperCase();
            return;
        }
        if (e.key === 'ArrowUp') { wpm++; unit = 1200/wpm; document.getElementById('wpm-text').innerText = wpm + " WPM"; return; }
        if (e.key === 'ArrowDown') { wpm--; unit = 1200/wpm; document.getElementById('wpm-text').innerText = wpm + " WPM"; return; }
        if (e.key === 'Backspace') { decodedText = ""; document.getElementById('output').innerText = ""; return; }

        if (mode === 'straight' && e.code === 'Space') {
            isStraightDown = true;
            this.downT = Date.now();
            soundControl(true);
        } else if (mode === 'paddle' && (e.key === '[' || e.key === ']')) {
            activePaddle = e.key;
            paddleProcess();
        }
    });

    window.addEventListener('keyup', (e) => {
        if (mode === 'straight' && e.code === 'Space') {
            const dur = Date.now() - this.downT;
            const ratio = dur / unit;
            if (ratio > 0.1) addSym(ratio < 2.2 ? '.' : '-');
            soundControl(false);
            isStraightDown = false;
        } else if (mode === 'paddle' && (e.key === '[' || e.key === ']')) {
            if (activePaddle === e.key) activePaddle = null;
        }
    });

    // 단어 공백 처리 (RX 상태에서만)
    setInterval(() => {
        const gap = Date.now() - lastInputTime;
        const state = document.getElementById('state-indicator').innerText;
        if (state === "RX" && decodedText !== "" && !decodedText.endsWith(" ")) {
            if (gap > unit * 7) {
                decodedText += " ";
                document.getElementById('output').innerText = decodedText;
            }
        }
    }, 100);
</script>
</body>
</html>
